---
title: CMAQ點源變數檔案之準備
tags: CMAQ ptse
layout: article
aside:
  toc: true
sidebar:
  nav: layouts
---

## 前言

顧名思義，這支程式就是為了產生CMAQ所需的點源排放量中隨時間變化的部分。

由於CMAQ執行與檔案系統都是以日期為主體，因此點源隨時間變化部分最後也要整理切割成以日期為單位的檔案。

執行變數檔案轉換之前，必須先執行常數檔案之轉換，主要是REAS點源排放量的處理是在前一階段執行。
## 緣起

- 在CAMx(與傳統的UAM)中，點源檔案與其他檔案最大的不同就是有常數部分的檔頭，其他檔案可能只有4筆header(詳CAMx(UAM)的檔案格式)，點源因有煙囪位置、排放條件等，這些不會隨著時間有所改變，因此放在檔頭。即使6/7等最新版nc格式，仍然採取此一策略。
- CMAQ也照此原則擴充，另外將常數項、變數項予以分開。
- 在新版的CMAQ中，也取消了隨時間變化的煙囪上升高度項，另外在模式中計算，這一點是引進CAMx的優勢強項。
- CMAQ/CAMx排放量檔案的演進、格式與單位的差異、轉換、等等，可以參考CMAQ/CAMx排放量檔案之轉換。
思路策略

如前述此二模式檔案有此背景，因此在準備時就不需猶豫該採取什麼策略，將原始數據先整理成CAMx檔案的格式，再將其發展程常數及變數2個檔案，再進行日期劃分，就會是最精簡、省工的方向。考慮因素：
- CAMx檔案同時有常數及變數項，不會出現檔案配對的困擾(CMAQ必須在run_cctm.csh中才能確認其配對關係)。
- 就時間項而言，CAMx保持較大的時間範圍，雖然檔案較大，處理起來有些不方便，但檔案管理輕鬆很多。適合系統性的改變。CMAQ逐日檔案如果要進行系統性的修改，還是必須從源頭、系統性來改，在逐日檔案內一一修改將事倍功半。
- CMAQ逐日的好處是有臨時性、局部針對性的修改，小檔案當然會比大檔案方便很多。不過這種情況應該很少(或儘量避免發生)才是。
程式設計

記憶體管理

由於同時要記錄2萬多筆點源（上限為25000筆、詳模版之準備）700多小時的變量，矩陣和記憶體耗費很大，在DEVP甚至不能同時有3個程式同時執行(單一程式記憶體即達到VERT 102g、DEVP的25%、node01~3之52%)，因此有必要好好檢討其記憶體的使用。
原則如下：
- 最花時間與記憶體的動作是模版的準備與展開，需要知道REAS csv及CAMx點源檔案時間、點源個數、污染物名稱等等條件。如果同時開啟勢必耗費記憶體。
- 策略上第一次開啟這2個唯讀檔只需讀取前述條件，可以展開模板即可，隨即關閉檔案（line 32~39）
	- REAS csv檔案雖然不大，但因現階段只需知道其長度，根本不必開啟，直接用wc -l指令就可以知道(line 30)
- 暫時性之矩陣使用相同的名字（ARR），可以減少使用記憶體～4G。
```
    30    len_df=int(subprocess.check_output('wc -l '+'point_reas16'+mm+".csv |awk '{print $1'}",shell=True).decode('utf8').strip('\n'))-1
    31    #input the CAMx ptsource file
    32    fname1=sys.argv[1]
    33    pt = netCDF4.Dataset(fname1,'r')
    34    v2=list(filter(lambda x:pt.variables[x].ndim==2, [i for i in pt.variables]))
    35    nt,nopts=pt.variables[v2[0]].shape
    36    fname0='template.timvar.nc'
    37    nc = netCDF4.Dataset(fname0,'r')
    38    v4=list(filter(lambda x:nc.variables[x].ndim==4, [i for i in nc.variables]))
    39    nc.close()
```

模版的準備
timvar的模版可以參考CMAQ公開包裏的檔案。
- 先將其時間TSTEP剪下1小時(ncks -d)，再將NCOLS即點源個數剪個25000筆，確切的筆數由TEDS及REAS資料庫再決定。
- 筆數如果超過，必須重複此動作

展開模版檔案
- 在nc檔案內使用迴圈非常費時，應儘量避免。
	- 54～79是展開模版的歷程，無法避免。但是讓時間標籤先填入0，展開後再整批帶入，會比一一對照要快很多。
	- 77～78開啟mask的過程，是最花時間的段落，因為nc基本上是個DICT、不適用整批帶入，沒辦法再更快。
	- 關閉檔案再開啟：經測試並不會減省大量的記憶體。反而過多IO拖慢程式的速度
	- 模版之展開（line 71～72）
	- TFLAG填入日期時間（73～76）
		- 使用dt2jul函數，將datetime.timedelta計算結果轉成日期及時間陣列
		- 整理成nt*2的陣列，轉到nt*NVARS*2的大陣列
		- 一併填入TFLAG內
		- 如果有ETFLAG可以參考mod_tflag.py（適用uamiv檔案，如果沒有ETFLAG、aok等等很多程式會出錯）
	- 防止陣列被mask鎖住（77~78）
	- 儘量不要用2個nc檔案直接傳遞數值。
```
    54    nc = netCDF4.Dataset(fname,'r+')
    55    jt=nt
    56    v4=list(filter(lambda x:nc.variables[x].ndim==4, [i for i in nc.variables]))
    57    nc.NROWS=nopts+len_df
    58    nc.GDNAM='EAsia_81K'
    59    nc.P_ALP = np.array(10.)
    60    nc.P_BET = np.array(40.)
    61    nc.P_GAM = np.array(120.98999786377)
    62    nc.XCENT = np.array(120.98999786377)
    63    nc.YCENT = np.array(23.6100196838379)
    64    nc.XCELL=XCELL #27000.000
    65    nc.YCELL=XCELL #27000.000
    66    nc.XORIG=XORIG #-877500.0
    67    nc.YORIG=XORIG #-877500.0
    68    nc.SDATE=dt2jul(start)[0]
    69    nc.STIME=dt2jul(start)[1]
    70    
    71    for t in range(totalH):
    72      nc.variables['TFLAG'][t,:,:]=0
    73    sdt=np.array([dt2jul(start+datetime.timedelta(days=t/24.)) for t in range(totalH)]).flatten().reshape(totalH,2)
    74    ARR=np.zeros(shape=(totalH,nc.NVARS,2))
    75    ARR[:,:,:]=sdt[:,None,:]
    76    nc.variables['TFLAG'][:,:,:]=ARR[:,:,:]
    77    for v in v4:
    78      nc.variables[v][:,0,:,0]=0. #np.zeros(shape=(totalH,nopts+len(df)),dtype='float32')
    79    print('save blank file')
```
mod_tflag.py
- 本程式是製作2019年各月CAMx模擬結果的模版，藉此執行aok以匯總EPA測站數據之ovm.csv/ovm.dat_camx
- d_hrs是TFLAG/ETFLA的差異，前者是模擬開始時間、後者是TFLAG+TSTEP，模擬結束時間
	- 此處TSTEP是1小時
- 
```
kuang@114-32-164-198 /Users/camxruns/2019/outputs
$ cat -n mod_tflag.py 
     1    import datetime
     2    import netCDF4
     3    import numpy as np
     4    def dt2jul(dt):
     5      yr=dt.year
     6      deltaT=dt-datetime.datetime(yr,1,1)
     7      deltaH=int((deltaT.total_seconds()-deltaT.days*24*3600)/3600.)
     8      return (yr*1000+deltaT.days+1,deltaH*10000)
     9    def jul2dt(jultm):
    10      jul,tm=jultm[:]
    11      yr=int(jul/1000)
    12      ih=int(tm/10000.)
    13      return datetime.datetime(yr,1,1)+datetime.timedelta(days=int(jul-yr*1000-1))+datetime.timedelta(hours=ih)
    14    
    15    v='TFLAG'
    16    for m in range(7,13):
    17      mo='{:02d}'.format(m)
    18      fname='con'+mo+'/19'+mo+'base.S.nc'
    19      nc = netCDF4.Dataset(fname,'r+')
    20      V=[list(filter(lambda x:nc.variables[x].ndim==j, [i for i in nc.variables])) for j in [1,2,3,4]]
    21      totalH, nlay, nrow, ncol = (nc.variables[V[3][0]].shape[i] for i in range(4))
    22      start=datetime.datetime(2019,int(mo),1,nc.STIME//10000)+datetime.timedelta(days=-1)
    23      nc.SDATE=dt2jul(start)[0]
    24      d_hrs={'TFLAG':0,'ETFLAG':1}
    25      for v in d_hrs:
    26        for t in range(totalH):
    27          nc.variables[v][t,:,:]=0
    28        sdt=np.array([dt2jul(start+datetime.timedelta(days=(t+d_hrs[v])/24.)) for t in range(totalH)]).flatten().reshape(totalH,2)
    29        ARR=np.zeros(shape=(totalH,nc.NVARS,2))
    30        ARR[:,:,:]=sdt[:,None,:]
    31        nc.variables[v][:,:,:]=ARR[:,:,:]
    32      nc.close()
    33    # pncgen --format=uamiv -O 1905base.S.grd01 1905base.S.nc 
    34    #  for i in {07..12};do cp con05/1905base.S.nc con$i/19${i}base.S.nc;done
    35    # for i in {07..12};do pncgen -O --out-format=uamiv con$i/19${i}base.S.nc con$i/19${i}base.S.grd01;done
```


CAMx部分的污染物對照
- 重複使用ARR：並使用空維度None，對速度提升與降低記憶體使用都很有效
- 執行完畢將變數歸0，對減少記憶體也不無幫助（98～99）
```
    81    #CAMx_pt part
    82    mpsp={'PNA':'NA','POC':'POA','XYLMN':'XYL'}
    83    ARR=(pt.variables['CPRM'][:,:]+pt.variables['FPRM'][:,:])/ 3600.
    84    nc.variables['PMOTHR'][idx:idx+jt,0,:nopts,0]=ARR[:,:]
    85    with_data=['PMOTHR']
    86    
    87    for v in mpsp: #mpsp={'PNA':'NA','POC':'POA','XYLMN':'XYL'}
    88      if v not in mpsp or mpsp[v] not in v2:continue
    89      ARR[:,:]=np.array(pt.variables[mpsp[v]][:,:nopts], dtype='float32')/ 3600.
    90      nc.variables[v][idx:idx+jt,0,:nopts,0]=ARR[:,:]
    91      with_data.append(v)
    92    
    93    for v in v2: #ptse from CAMx
    94      if v not in v4:continue #outside of v4 (the template)
    95      ARR[:,:]=np.array(pt.variables[v][:,:nopts],dtype='float32') / 3600. #gmole/hr -> gmole/sec
    96      nc.variables[v][idx:idx+jt,0,:nopts,0]=ARR[:,:]
    97      with_data.append(v)
    98    pt=0.
    99    ARR=0.
```
REAS part
- 這部分容量並不增加、計算速度也不低，
- CBM成分累加部分（117~133）與nc檔案脫鉤，在時間迴圈之外執行，這樣才有效率
```
   100    #REAS part
   101    print('REAS part')
   102    df=read_csv('point_reas16'+mm+'.csv')
   103    specs=[ i for i in df.columns if i not in ['lon','lat','x_m','y_m']]
   104    ARR=np.zeros(shape=(jt,len_df))
   105    with open('reas2cmaq.json','r') as f:
   106      r2c=json.load(f)
   107    for v in specs:
   108      if v == 'NOX':continue
   109      if sum(np.array(df[v]))==0.:continue
   110      if v not in r2c :continue
   111      if type(r2c[v])==str: #simple mapping of specs
   112        if r2c[v] not in v4:continue
   113        a=np.array(df[v])
   114        ARR[:,:]=a[None,:]
   115        nc.variables[r2c[v]][idx:idx+jt,0,nopts:,0]=ARR[:,:]
   116        with_data.append(r2c[v])
   117    cbm=set()
   118    sv=[]
   119    for v in specs:
   120      if v not in r2c :continue
   121      if type(r2c[v])!=str:
   122        sv.append(v)
   123        cbm=cbm.union(set(r2c[v]))
   124    cbm=list(cbm)
   125    ARR=np.zeros(shape=(len(cbm),len_df))
   126    for v in sv:
   127      for i in r2c[v]:
   128        ARR[cbm.index(i),:]+=np.array(df[v])
   129    Acbm=np.zeros(shape=(jt,len(cbm),len_df))
   130    Acbm[:,:,:]=ARR[None,:,:]
   131    for v in cbm:
   132      nc.variables[v][idx:idx+jt,0,nopts:,0]=Acbm[:,cbm.index(v),:]
   133      with_data.append(v)
```
前一天排放補值
CAMx 是逐月檔，但在CMAQ是跟著WRF的批次，因此可能在每月的前後會需要多一點時間（小月問題），過去以手動方式加值，現則直接以程式添加。
```
   135    for v in v4:
   136      if v not in with_data:continue
   137      a=nc.variables[v][24:idx+24,0,:,0]
   138      nc.variables[v][:idx,0,:,0]=a[:,:]
   139      a=nc.variables[v][idx-jt-24:totalH-24,0,:,0]
   140      nc.variables[v][idx-jt:totalH,0,:,0]=a[:,:]
   141    
   142    nox= nc.variables['NO2'][:,0,:,0]+nc.variables['NO'][:,0,:,0]
   143    
   144    ARR=np.zeros(shape=(jt,len_df))
   145    a=np.array(df['NOX'])
   146    ARR[:,:]=a[None,:]
   147    nox[idx:idx+jt,nopts:]=ARR[:,:]
   148    nc.variables['NO2'][:,0,:,0]=nox *1./10.
   149    nc.variables['NO'][:,0,:,0] =nox *9./10.
   150    # print(v)
   151    nc.close()

```
後處理
brk_day2.cs(*)
- 將逐月檔案分割成駐日檔案，放在YYMM目錄下（詳見CMAQ/CAMx排放量檔案之轉換）。
- 小月不夠檔案的問題，可以用下面的腳本檢查、連結下月檔補足
```
cat /Users/cmaqruns/2019base/data/emis/ln_run12.cs
for m in {01..12};do
YM=$(date -ud "2019-${m}-1 -1 day" +%Y-%m)
YP=$(date -ud "2019-${m}-1 +1 month" +%y%m)
ED=$(date -ud "${YM}-15 + 48 day" +%Y%m%d)
LAST=$(ls 19$m|T -n1|cut -d'.' -f2)
NX=$(date -ud "${LAST} + 1 day" +%Y%m%d)
for ((d=$NX;d<=ED;d=$(date -ud "${d} + 1 day" +%Y%m%d)));do
echo $m $d
cd 19$m
ln -s ../$YP/*${d}* .
cd ..
done
done
```
ln_run12.cs
- 月份檔案分成逐日檔案之後，因為小月天數不足，有可能涵蓋到更多下月初的日子
- 此事也可在程式內解決，也可簡單地以下月初的天數來補足
- 以下腳本即為確認與連結所用
- 不單用在點源、任何分月檔案都可以查核、連結
	- 日期必須在.間隔的第2欄，如teds11.20190101.timvar.nc。
```
kuang@centos8 ~/bin
$ !cat
cat -n ln_run12.cs
     1    YR=$(echo $PWD|cut -d'/' -f4|cut -c1-4)
     2    yy=$(echo $PWD|cut -d'/' -f4|cut -c3-4)
     3    for m in {01..12};do
     4    YM=$(date -ud "${YR}-${m}-1 -1 day" +%Y-%m)
     5    YP=$(date -ud "${YR}-${m}-1 +1 month" +%y%m)
     6    ED=$(date -ud "${YM}-15 + 48 day" +%Y%m%d)
     7    LAST=$(ls ${yy}$m|T -n1|cut -d'.' -f2)
     8    NX=$(date -ud "${LAST} + 1 day" +%Y%m%d)
     9    for ((d=$NX;d<=$ED;d=$(date -ud "${d} + 1 day" +%Y%m%d)));do
    10    echo $m $d
    11    cd ${yy}$m
    12    ln -s ../$YP/*${d}* .
    13    cd ..
    14    done
    15    done
    16    
```
Pt2em_d1.py
- 程式說明參考CMAQ/CAMx排放量檔案之轉換
- 引數：包括前綴及年月
```
python /Users/cmaqruns/2016base/data/ptse/twn/pt2em_d01.py teds11.201901
```
結果檢查

Resources
Barron  Henderson, pseudonetcdf tutorial, http://www.barronh.com/software/tutorials/pseudonetcdf-tutorial
verdi usage https://www.airqualitymodeling.org/index.php/VERDI_1.5_User_Manual#3.1_Installation_Instructions_for_Linux_and_Mac
VERDI使用說明 : http://www.evernote.com/l/AH3leuVQTuBEF7Vrs0D1C8Q-Iff5CpHl7eU
pt2emNest:https://github.com/sinotec2/CAMx_utility/blob/master/pt2emNest.f
[ncks](https://boostnote.io/shared/7566f2e7-f9aa-4a00-ba74-616ea8f72d25)
Example
https://github.com/sinotec2/cmaq_relatives/blob/master/run_cctmMM_RR_DM.csh
Notes
- CAMx(UAM)的檔案格式, Yungchuan Kuang edited this page on 12 Jul 2016 · 2 revision, shttps://github.com/sinotec2/camxruns/wiki/CAMx(UAM)的檔案格式
- Here: pt_timvar.py
- BoostNote: pt_timvarLL.py程式說明
- Relatives:
  pt_const.pyCMAQ/CAMx排放量檔案之轉換D4範圍地面排放檔案之轉換CMAQ compilationsCMAQ初始及邊界條件設定REASv3.1排放檔案之處理 CAMx(UAM)的檔案格式
