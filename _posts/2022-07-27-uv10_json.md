---
title: 地面風wrfout檔轉json
tags: CWBWRF python
layout: article
aside:
  toc: true
sidebar:
  nav: layouts
date:  2022-07-27
modify_date: 2022-07-27 21:39:00
mermaid: true
---
## 背景
- 雖然[nc2json][nc2json]已經有網友貢獻了，此處除了檔案轉換之外，還需要轉換座標系統，將CWB wrf預報檔中原本的藍伯特投影等間距網格、轉換成等經緯度網格。
- 目的是應用cambecc的[earth][ens]套件。
  - 該套件內設讀取的是gfs預報結果檔，解析度為1度。
  - gfs與CWB檔案的差異比較詳見[earth套件讀取CWB_WRF數據][diff_tab]。
  - 由於差異太多，不易在js內修改，在系統外直接以gfs的json模版來填入CWB內容，會較為容易。
- CWB wrf預報檔之下載、解析、轉換詳見[FAQ：中央氣象局WRF_3Km數值預報產品][wrf_3km]。
- 雖然可以應用leaflet等js模組進行座標轉換，但因為CWB_WRF已經有WPS-geogrid結果，內中有XLAT與XLONG等2項經緯度變數（詳見[cwb WRF_3Km->相同網格系統之grb2轉檔][fil_grb_nc]），不需要另外進行座標轉換的計算，直接內插即可。

## 程式IO
### input
- 引數：欲處理的wrfout檔名
  - 結果會按照檔名中的d01或d03設定解析度標籤(15K or 3K)
- json 模版
  - current-wind-surface-level-gfs-1.0.json
  - 自cambecc的github取得:`wget https://raw.githubusercontent.com/cambecc/earth/master/public/data/weather/current/current-wind-surface-level-gfs-1.0.json`

### output
- 解析度標籤不同
  - d01:`'current-wind-surface-level-cwb-15K.json'`
  - d03:`'current-wind-surface-level-cwb-3K.json'`
- 位置：結果檔必須放在`/Users/Data/javascripts/D3js/` `./earth/public/data/weather/current`目錄下

## 程式分段說明
### 經緯度範圍
- 因為藍伯特投影直角座標系統（LCC）的4角點數不足以內插，將會出現很多NaN的結果，因此必須將其去除。
- 考量到解析度的不均勻，LCC的中心解析度較高，周圍較差。
- 經度的範圍
  - 東西邊界上的最南點
  - 規避負值的經度（換日線東方）
- 緯度的範圍
  - 東西邊界上的最北點，取較低值。其確切值以bisect在中心線中決定(`lat_max` and `jm`)
  - 中心線的最南點(`lat_min`)

```python
x=nc.variables['XLONG'][0,:,:]
y=nc.variables['XLAT'][0,:,:]
lat_min=y[0,ncol//2]
lat_max=np.min([y[-1,-1],y[-1,0]])
jmx=bisect(y[:,ncol//2],lat_max)
lat_max=y[jmx,ncol//2]
dy=(lat_max-lat_min)/jmx
dx=dy

lon_min=np.max(x[:,0])
idx=np.where(x[:,-1]>0)
lon_max=np.min(x[idx[0],-1])
nx=int((lon_max-lon_min)//dx)
ny=int((lat_max-lat_min)//dy)
```

### 產生新的經緯度網格系統
- `idx`是新網格範圍內的點。經過篩選大致上可以留下7.5～8成。

```python
#new grid system(x1,y1) in equal dlat and dlon
lon1d=[lon_min+dx*i for i in range(nx)]
lat1d=[lat_min+dy*i for i in range(ny)]
x1, y1 = np.meshgrid(lon1d, lat1d)
idx=np.where((x>0)&(x>=lon_min)&(x<=lon_max)&(y>=lat_min)&(y<=lat_max))
mp=len(idx[0])
xyc= [(x[idx[0][i],idx[1][i]],y[idx[0][i],idx[1][i]]) for i in range(mp)]
```

### 填入json模版
- 先將網格座標系統相關設定填入gfs
- json的實數必須是64位元

```python
for i in range(nr):
  gfs[i]['header']['nx']=nx
  gfs[i]['header']['ny']=ny
  gfs[i]['header']['numberPoints']=nx*ny
  for v in ['dx','dy']:
    gfs[i]['header'][v]=np.float64(dx)
  gfs[i]['header']['lo1']=np.float64(lon_min)
  gfs[i]['header']['lo2']=np.float64(lon_max)
  gfs[i]['header']['la2']=np.float64(lat_min)
  gfs[i]['header']['la1']=np.float64(lat_max)
  gfs[i]['data']=[0 for v in range(nx*ny)]
```

### 2維線性內插
- 使用`np.where`將周邊少數NaN值設為0
- GFS定義y軸是自北向南，與wrf相反。在壓平（`np.flatten()`）前必須先將y軸反轉（`np.flip(...)`）。

```python
uv=['U10', 'V10']
for ir in range(nr):
  var=nc.variables[uv[ir]][0,:,:]
  c = np.array([var[idx[0][i], idx[1][i]] for i in range(mp)])
  zz = griddata(xyc, c[:], (x1, y1), method='linear')
  gfs[ir]['data']=list(np.flip(np.where(zz!=zz,0,zz),axis=0).flatten())
```

### 寫出檔案

```python
if 'd01' in fname:fnameO='current-wind-surface-level-cwb-15K.json'
if 'd03' in fname:fnameO='current-wind-surface-level-cwb-3K.json'
with open(fnameO,'w') as f:
  json.dump(gfs,f)
```

## 程式下載

{% include download.html content="地面風wrfout檔轉json：[uv10_json.py](https://github.com/sinotec2/Focus-on-Air-Quality/blob/main/wind_models/cwbWRF_3Km/uv10_json.py)" %}

[nc2json]: <https://github.com/pwcazenave/netcdf2json/blob/master/netcdf2json.py> "pwcazenave(2017), Convert netCDF output to JSON for use in earth, netcdf2json"
[diff_tab]: <https://sinotec2.github.io/FAQ/2022/07/26/CWBwrf_3Km2NWC.html> "earth套件讀取CWB_WRF數據-> diff of first paramter in gfs and cwbwrf_15Km files"
[ens]: <https://earth.nullschool.net/> "earth, a visualization of global weather conditions, forecast by supercomputers, updated every three hours"
[wrf_3km]: <https://sinotec2.github.io/Focus-on-Air-Quality/wind_models/cwbWRF_3Km/> "中央氣象局WRF_3Km數值預報產品"
[fil_grb_nc]: <https://sinotec2.github.io/Focus-on-Air-Quality/wind_models/cwbWRF_3Km/fil_grb_nc/> "cwb WRF_3Km->相同網格系統之grb2轉檔"
